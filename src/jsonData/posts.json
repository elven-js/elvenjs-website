[{"fileName":"getting-started.html","title":"Getting started","body":"<p>Elven.js is a tool designed to work in browsers without any build steps and integrate MultiversX blockchain and smart contracts built on it.</p> <p>The tool is a wrapper for <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">sdk-js</a> - a set of Typescript/Javascript libraries. But because the sdk-js toolset is quite extensive and has a lot of Node module dependencies, there is a need for a simple browser-only library. The Elven.js aspire to be something like that - a helpful plug-and-play solution that will give you the most basic functionalities.</p> <h2>What Elven.js can do?</h2> <p>The fundamental functionality is connecting and logging the user using auth providers. For now, Elven.js supports three of four existing - The MultiversX <a href=\"https://chrome.google.com/webstore/detail/multiversx-defi-wallet/dngmlblcodfobpdpecaadgfbcggfjfnm\">browser extension</a> (MultiversX Defi), <a href=\"https://xportal.com/\">xPortal Mobile app</a>, and MultiversX Web Wallet. In the future, it will also support <a href=\"https://www.ledger.com/\">Ledger Nano</a> hardware wallet.</p> <p>So basically, the user can attach the Elven.js script and start authenticating users on the front end. There is also an option to pass a unique token and get a signature after authentication, which you can use for additional backend verification. You will read more about it in the <a href=\"/docs/recipes.html\">recipes</a> section.</p> <p>Besides authentication, Elven.js will also help with all the interactions, like sending native $EGLD tokens or even ESDT tokens. It will allow you to make most transactions, including interactions with custom smart contracts. There is also a possibility to query smart contracts. For now, you need to decode the returned data using custom logic, but there will be a separate utility soon.</p> <h2>How is Elven.js built?</h2> <p>In the end, the Elven.js library is a simple browser-based JS script. You can copy it from the repository and use it as a local JavaScript file or import it directly from the CDN.</p> <p>The script is a wrapper for sdk-js, an official JavaScript SDK for usage in the Nodejs ecosystem. JS SDK can also be used in the browser but requires additional build steps and configuration, and the file itself will be huge. This is why Elven.js exists.</p> <p>Elven.js imports only crucial parts of the sdk-js libraries. It will include the most used parts of the sdk-js, which are essential for the browsers. All other functionality will be split into separate scripts, and it will be shipped as optional scripts in the future.</p> <p>Internally Elven.js uses Typescript, but finally, it is a standard minified JavaScript file. It can be used in static websites and frameworks like React, SolidJS, or Vue. It is worth mentioning that there are official tools for React already, so it will probably be a better choice to check them. You could also check the <a href=\"https://github.com/xdevguild/nextjs-dapp-template\">MultiversX NextJs dApp template</a>.</p> <h2>How to start using it?</h2> <p>Because Elven.js is just a JavaScript file, you can import it from CDN and start using its inner parts. You can also copy the file version from the <a href=\"https://github.com/elven-js/elven.js/tree/main/build\">build</a> directory in the repository.</p> <p>Let's see how to import it from the CDN:</p> <pre><code class=\"language-html\">&#x3C;html>   &#x3C;body>     &#x3C;script type=\"module\">       import { ElvenJS } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';        const initElven = async () => {         await ElvenJS.init(           {             apiUrl: 'https://devnet-api.multiversx.com',             chainType: 'devnet',             apiTimeout: 10000,             // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in             walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',             walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],             onLoginPending: () => {},             onLoggedIn: () => {},             onLogout: () => {},             onTxStarted: () => {},             onTxSent: () => {},             onTxFinalized: () => {},             onTxError: () => {},             onQrPending: () => {},             onQrLoaded: () => {},           }         );       }        initElven();     &#x3C;/script>   &#x3C;/body> &#x3C;/html> </code></pre> <p>As you can see here, we have a simplified HTML document where we import the Elven.js SDK parts. Always check the version number (the example from here is v0.13.0: <code>elven.js@0.13.0</code>).</p> <p>You can check the demo examples linked on the homepage.</p> <p>If you work with a frontend framework for which no tools support the MultiversX blockchain, you can also use the Elven.js tools, installing them as a dependency and then importing from it.</p> <pre><code class=\"language-bash\">npm install elven.js --save </code></pre> <p>Example with SolidJs:</p> <pre><code class=\"language-typescript\">import { ElvenJS } from 'elven.js';  (...)  onMount(() => {   const initElven = async () => {     await ElvenJS.init({       apiUrl: 'https://devnet-api.multiversx.com',       chainType: 'devnet',       apiTimeout: 10000,       // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in       walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',       walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],       onLoginPending: () => {},       onLoggedIn: () => {},       onLogout: () => {},       onTxStarted: () => {},       onTxSent: () => {},       onTxFinalized: () => {},       onTxError: () => {},       onQrPending: () => {},       onQrLoaded: () => {},     });   };    initElven(); });  (...) </code></pre> <p>Because of the ability to adapt to any frontend framework Elven.js is an excellent choice for all widget-like implementations. Imaging WordPress or Shopify plugins with it. Or, for example, simple donation widgets for static hobby websites. You can find such an example here: <a href=\"https://elrond-donate-widget-demo.netlify.app/\">elrond-donate-widget-demo.netlify.app</a>.</p> <h2>Demo video</h2> <p>Remember that the video will be outdated. Check the version and <a href=\"https://github.com/elven-js/elven.js/blob/main/CHANGELOG.md\">changelog</a>.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/tcTukpkjcQw\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h2>Summary</h2> <p>Okay, so you know what Elven.js is and how to start using it. You are now ready to look at the <a href=\"/docs/sdk-reference.html\">SDK reference</a> and <a href=\"/docs/recipes.html\">recipes</a>.</p> <p>Also, there are a lot of links to the demo applications on the homepage, so you could also check the code of each one.</p>","excerpt":"Elven.js - the JavaScript SDK for the MultiversX blockchain. Compact and simplified wrapper for sdk-js!","publicationDate":"2022-09-20","tags":["intro"],"coverImage":""},{"fileName":"recipes.html","title":"Recipes","body":"<p>In this section, we will check real-world examples. Of course, you can also check the code in many demos linked on the homepage. Let's see the most common cases here.</p> <p>Remember that you can use the ElvenJS not only in static websites but let's focus only on such ones for simplicity. Check the linked demos on StackBlitz to learn how to use it, for example, with Vue or SolidJS.</p> <h3>How to login and logout with auth providers</h3> <p>ElvenJS offers two of four auth providers for now. They are the <a href=\"https://xportal.com/\">xPortal Mobile app</a>, <a href=\"https://chrome.google.com/webstore/detail/multiversx-defi-wallet/dngmlblcodfobpdpecaadgfbcggfjfnm\">MultiversX browser extension</a>, and MultiversX Web Wallet. There will also be support for the <a href=\"https://www.ledger.com/\">Ledger Nano</a> and Ledger Nano.</p> <p>To be able to login you need to initialize ElvenJs and then use the login function:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-login-extension\" style=\"display: none;\">Login with Extension&#x3C;/button>   &#x3C;button class=\"button\" id=\"button-login-mobile\" style=\"display: none;\">Login     with xPortal&#x3C;/button>   &#x3C;button class=\"button\" id=\"button-logout\" style=\"display: none;\">Logout&#x3C;/button>    &#x3C;div id=\"qr-code-container\" class=\"qr-code-container\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiLoggedInState,       uiPending,     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       await ElvenJS.init(         {           // Define the API endpoint (can be custom one)           apiUrl: 'https://devnet-api.multiversx.com',           // Define the chain type (devnet, mainnet, testnet)           chainType: 'devnet',           // Define the API timeout, max 10 sec on public endpoint           apiTimeout: 10000,           // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in           walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',           // WalletConnectV2RelayAddresses are required only for custom addresses           // by default it will use ['wss://relay.walletconnect.com']           walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],           // Define login callback functions           onLoginPending: () => { uiPending(true) },           onLoggedIn: () => { uiLoggedInState(true); uiPending(false) },           onLogout: () => { uiLoggedInState(false); },           // Define transactions callbacks (all are optional)           onTxStarted: (tx) => { uiPending(true); },           onTxSent: (tx) => { console.log('Tx sent, but not finalized on the chain!'); },           onTxFinalized: (tx) => {              tx?.hash &#x26;&#x26; updateTxHashContainer(tx.hash); uiPending(false);           },           onTxError: (tx, error) => { uiPending(false); },           onQrPending: () => { uiPending(true); },           onQrLoaded: () => { uiPending(false); },         }       );     }      // Trigger the async init function      initElven();      // Add event listener for extension login button      document       .getElementById('button-login-extension')       .addEventListener('click', async () => {         try {           await ElvenJS.login('browser-extension');         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      // Add event listener for mobile login button      // You will need a container for the qr code     document       .getElementById('button-login-mobile')       .addEventListener('click', async () => {         try {           await ElvenJS.login('mobile', {             // You can also use the DOM element here:              // qrCodeContainer: document.querySelector('#qr-code-container')             qrCodeContainer: 'qr-code-container',           });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      // Add event listener for web login button      // You can pass the callback url - the landing page after login on web wallet website     document       .getElementById('button-login-web')       .addEventListener('click', async () => {         try {           await ElvenJS.login('web-wallet', { callbackRoute: '/' });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      // Add event listener for logout button     document       .getElementById('button-logout')       .addEventListener('click', async () => {         try {           // Trigger the ElvenJS logout           const isLoggedOut = await ElvenJS.logout();         } catch (e) {           console.error(e.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>After using one of the login methods, your data will be kept in the localStorage for further usage and synchronization. No worries, nothing private.</p> <p>From now on, you can sign and send transactions.</p> <h3>How to send EGLD</h3> <p>For this example, let's omit the code responsible for initialization and auth. You can check it above. Let's focus on the EGLD operations:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-tx\" style=\"display: none;\">EGLD transaction&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Transaction,       Address,       TransactionPayload,       TokenTransfer     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // (...) Init and login logic here, check how above      const egldTransferAddress = 'erd17a4wydhhd6t3hhssvcp9g23ppn7lgkk4g2tww3eqzx4mlq95dukss0g50f';      // Event listener for predefined EGLD transaction     document       .getElementById('button-tx')       .addEventListener('click', async () => {         updateTxHashContainer(false);         const demoMessage = 'Transaction demo from Elven.js!';          const isGuarded = ElvenJS.storage.get('activeGuardian');                  // predefined transaction, this is how it is usually built         const tx = new Transaction({           // Get the actal nonce from storage           nonce: ElvenJS.storage.get('nonce'),           // Get the receiver of the EGLD           receiver: new Address(egldTransferAddress),           // Calculate gas limit (check MultiversX docs)           // You will need additional 50000 when using guardians           gasLimit: (isGuarded ? 100000 : 50000) + 1500 * demoMessage.length,           // Define the chain id (D for the devnet, T for the testnet, 1 for the mainnet)           chainID: 'D',           // Build transaction payload data, here very simple string           data: new TransactionPayload(demoMessage),           // EGLD value to send           value: TokenTransfer.egldFromAmount(0.001),           // Your address, we can get it from the storage, because you should be loggedin           sender: new Address(ElvenJS.storage.get('address')),         });          try {           // Send the transaction           await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>As you can see, more logic is involved in building the transaction here. It could look not very easy, but generally, it is just an object created with a couple of helpers exported from sdk-js SDK. So it is very similar to how you would do this with sdk-js.</p> <p>Transactions are handled in very similar ways. They only need different payload structures and builders. You will find the whole list of them in the <a href=\"/docs/sdk-reference.html\">SDK reference</a>.</p> <p>Oh, and by the way, the transaction here is predefined, but you could have your logic that could take all the values from some form, user action etc.</p> <h3>How to send ESDT</h3> <p>The same here. Let's not focus on initialization and login. You can check it above in the first point.</p> <p>Below you will find an example of the ESDT transfer. What is ESDT? These are tokens on the MultiversX network that you can create for yourself. Please read more about them <a href=\"https://docs.multiversx.com/tokens/esdt-tokens/\">here</a>.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-tx-esdt\" style=\"display: none;\">ESDT transaction*&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,       updateQueryResultContainer     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Address,       TokenTransfer,       TransferTransactionsFactory,       GasEstimator,     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // (...) Init and login logic here, check how above       // ESDT address for demo purpose     const esdtTransferAddress = 'erd17a4wydhhd6t3hhssvcp9g23ppn7lgkk4g2tww3eqzx4mlq95dukss0g50f';      // Event listener for triggering the predefined ESDT transaction     document       .getElementById('button-tx-esdt')       .addEventListener('click', async () => {         updateTxHashContainer(false);          // We need to build the payment here, we need to provide some data         // Token id, amount and decimal places (check sdk-js cookbook for more info)         const payment = TokenTransfer.fungibleFromAmount(           'BUILDO-890d14',           '1',           18         );          // Here we are preparing the transfer factory         // We use default GasEstimator - this way we don't have to worry about providing gas limit vale         const factory = new TransferTransactionsFactory(new GasEstimator());          // And here we have actual transaction         // It doesn't need the value field, because we don't send the EGLD         const tx = factory.createESDTTransfer({           tokenTransfer: transfer,           receiver: new Address(esdtTransferAddress),           sender: new Address(ElvenJS.storage.get('address')),           chainID: 'D',         });          try {           // We use the same function as previously           const transaction = await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>How to mint NFT</h3> <p>Again, let's not focus on initialization and login. Check these above in the first point.</p> <p>Here we will mint an NFT on the <a href=\"https://www.elven.tools\">Elven Tools Minter Smart Contract</a> deployed on the devnet.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-mint\" style=\"display: none;\">Mint NFT&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,       updateQueryResultContainer     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Transaction,       Address,       TokenTransfer,       SmartContract,       ContractFunction,       U32Value,     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // (...) Init and login logic here, check how above ...      // Here is the Elven Tools demo minter smart contract on the devnet     // The one we will be calling to mint the NFT     const nftMinterSmartContract = 'erd1qqqqqqqqqqqqqpgq5za2pty2tlfqhj20z9qmrrpjmyt6advcgtkscm7xep';          // We need an event to trigger the mint     document       .getElementById('button-mint')       .addEventListener('click', async () => {         updateTxHashContainer(false);          // Again, we are preparing the data payload using different helpers         // The function on smart contract is called 'mint'         // It also takes one argument which is the amount to mint         const contractAddress = new Address(nftMinterSmartContract);         const contract = new SmartContract({ address: contractAddress });          const isGuarded = ElvenJS.storage.get('activeGuardian');          const tx = contract.call({           caller: new Address(ElvenJS.storage.get('address')),           value: TokenTransfer.egldFromAmount(0.01),           func: new ContractFunction(\"mint\"),           // You need 50000 more when using guardians           gasLimit: isGuarded ?  : 14050000 ? 14000000,           args: [new U32Value(1)],           chainID: \"D\"         })          try {           // We still use the same ElvenJS function for that,            // only the transaction instance is different           const transaction = await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>You can check more about the NFT tokens on the MultiversX blockchain in the docs <a href=\"https://docs.multiversx.com/tokens/nft-tokens/\">here</a>. Also, check the <a href=\"https://www.elven.tools\">Elven Tools</a> if you want to run your own PFP NFT collection on the MultiversX blockchain. Free and open source smart contract, CLI tool, and dApp template.</p> <h3>How to query a smart contract</h3> <p>Smart contracts can offer read-only endpoints/functions that you can query. Let's omit the initialization and login using ElvenJS here. Check it in the first point.</p> <p>We will query the minter smart contract to get the number of NFTs already minted by the wallet address. Such a functionality is programmed in the Elven Tools Smart Contract, and everyone can do the query.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-query\" style=\"display: none;\">Query SC&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,       updateQueryResultContainer     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Address,       AddressValue,       ContractFunction,     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // (...) Init and login logic here, check how above ...      // Here the same minter smart contract address as above. We will qery its function     const nftMinterSmartContract = 'erd1qqqqqqqqqqqqqpgq5za2pty2tlfqhj20z9qmrrpjmyt6advcgtkscm7xep';          document       .getElementById('button-query')       .addEventListener('click', async () => {         try {           updateQueryResultContainer();           uiPending(true);            // Here we use the queryContract function from ElvenJS           // we need to pass required values           const results = await ElvenJS.queryContract({             address: new Address(nftMinterSmartContract),             // The function on smart contract is called 'getMintedPerAddressTotal'             func: new ContractFunction('getMintedPerAddressTotal'),             // As an argument we need to pass our address to check in TypedValue type             // Check whole list in the SDK reference section             args: [new AddressValue(new Address(ElvenJS.storage.get('address')))]           });            uiPending(false);            // Manual decoding of a simple type (number here),            // there will be additional tools for that           // We know that it should be a number, so we can simply decode it using           // helper functions like base64 to decimal hex           // and then parse the hex number           // You'll find an example of such helper tool in the example directory in the repository           const hexVal = base64ToDecimalHex(results?.returnData?.[0]);           updateQueryResultContainer(`➡️ The result of the query is: ${parseInt(hexVal, 16)}`);         } catch (e) {           uiPending(false);           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>How to verify the user on the backend side</h3> <div class=\"docs-box docs-info-box\">You don't need to worry about this section if you don't plan to do any verification on the backend side of your application.</div> <p>By default elven.js uses <a href=\"https://www.npmjs.com/package/@multiversx/sdk-native-auth-client\">@multiversx/sdk-native-auth-client</a> under the hood.</p> <p>When logging in using one of the signing providers, a <code>loginToken</code> will be generated for you. It will then be used to acquire the signature. All with your account address will be then used to create <code>accessToken</code>. With that token, you can verify the user on the backend side, for example, using <a href=\"https://www.npmjs.com/package/@multiversx/sdk-native-auth-server\">@multiversx/sdk-native-auth-server</a>.</p> <h3>Transactions states and execution flow</h3> <p>When you use <code>ElvenJS.signAndSendTransaction</code>, a couple of callbacks will be called (You can define them in the <code>ElvenJS.init</code>), depending on the progress of current transactions.</p> <p>These are:</p> <ul>   <li><code>onTxStarted?: (transaction: Transaction) => void;</code></li>   <li><code>onTxSent?: (transaction: Transaction) => void;</code></li>   <li><code>onTxFinalized?: (transaction: Transaction) => void;</code></li>   <li><code>onTxError?: (transaction: Transaction, error: string) => void;</code></li> </ul> <p>They are self-explanatory. <code>onTxSent</code> will fire after sending (the transaction object will not contain the signature yet). The <code>onTxFinalized</code> will fire after the transaction is finalized on chain (the transaction object will contain the signature).</p> <p>In case of the error, the <code>onTxError</code> will additionally contain the error message.</p> <h3>Styling elements</h3> <p>There are a couple of elements that use external styles. Feel free to copy styles if needed. You can check the examples in the <code>example</code> directory.</p> <p>No styles are attached to QR code elements and WalletConnect pairings list by default. But each piece has CSS classes that you can use.</p> <p>The list of classes:</p> <ul>   <li><code>.elven-qr-code-deep-link</code></li>   <li><code>.elven-wc-pairings</code></li>   <li><code>.elven-wc-pairings-header</code></li>   <li><code>.elven-wc-pairing-item</code></li>   <li><code>.elven-wc-pairings-remove-btn</code></li>   <li><code>.elven-wc-pairing-item-description</code></li>   <li><code>.elven-wc-pairing-item-confirm-msessage</code></li> </ul> <p>For more info, check the demo in the <code>example</code> directory. Please let us know if you need more styling flexibility and options. Describe your use cases <a href=\"https://github.com/elven-js/elven.js/issues\">here</a>.</p> <h3>Working demos</h3> <p>The demos are linked on the homepage, but let's bring them also here:</p> <ul>   <li><a href=\"https://elvenjs.netlify.app/\">elvenjs.netlify.app</a> - EGLD, ESDT transactions, smart contract queries and transactions</li>   <li><a href=\"https://elrond-donate-widget-demo.netlify.app/\">elrond-donate-widget-demo.netlify.app</a> - donation-like widget demo</li>   <li><a href=\"https://stackblitz.com/edit/web-platform-d4rx5v?file=index.html\">StackBlitz vanilla html demo</a></li>   <li><a href=\"https://stackblitz.com/edit/vitejs-vite-rbo6du?file=src/App.tsx\">StackBlitz Solid.js demo</a></li>   <li><a href=\"https://stackblitz.com/edit/vitejs-vite-qr2u7l?file=src/App.tsx\">StackBlitz React demo</a></li>   <li><a href=\"https://stackblitz.com/edit/vue-zrb8y5?file=src/App.vue\">StackBlitz Vue demo</a></li> </ul> <p>You should be able to find the source code of each under the links.</p>","excerpt":"Elven.js - the JavaScript SDK for the MultiversX blockchain. Compact and simplified wrapper for sdk-js!","publicationDate":"2022-09-19","tags":["intro"],"coverImage":""},{"fileName":"sdk-reference.html","title":"SDK Reference","body":"<p>The Elven.js tool will be as simple as possible. It exports a couple of helper functions. It also exports several data structures (types) from <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">sdk-js</a> libraries. Here you will find a description of all the parts, and then you can check the <a href=\"/docs/recipes.html\">recipes</a> section for real-world examples.</p> <p>Worth mentioning. Remember to check the source code, written in Typescript. You will find all the source files here: <a href=\"https://github.com/elven-js/elven.js/tree/main/src\">elven.js/src</a>.</p> <h3>Initialization</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.init(initOptions: InitOptions) </code></pre> <p><strong>Typings</strong>:</p> <pre><code class=\"language-typescript\">interface InitOptions {   apiUrl: string;   chainType: string;   apiTimeout: number;   // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in   walletConnectV2ProjectId: string,   walletConnectV2RelayAddresses: string[],   onLoginPending?: () => void;   onLoggedIn?: () => void;   onLogout?: () => void;   onTxStarted: (tx: Transaction) => { uiPending(true); },   onTxSent: (tx: Transaction) => {}   onTxFinalized: (tx: Transaction) => {     tx?.hash &#x26;&#x26; updateTxHashContainer(tx.hash);     uiPending(false);   },   onTxError: (tx: Transaction, error: string) => { uiPending(false); }   onQrPending: () => void;   onQrLoaded: () => void; } </code></pre> <p>The primary initialization function. It is responsible for synchronizing with the MultiversX network and attaching login/logout callbacks.</p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>apiUrl</code>MultiversX API URL - can be the public or private instance,</li>   <li><code>chainType</code>Chain type identification - can be devnet, testnet, or mainnet,</li>   <li><code>apiTimeout</code>: The API call timeout in milliseconds. Maximum 10000,</li>   <li><code>walletConnectV2ProjectId</code>: Get yours from https://cloud.walletconnect.com/sign-in,</li>   <li><code>walletConnectV2RelayAddresses</code>: You can pass your custom WalletConnect relay adresses, by default it will use 'wss://relay.walletconnect.com'</li>   <li><code>onLoginPending</code>: On login pending callback. It is used across all the auth providers,</li>   <li><code>onLoggedIn</code>: On logged in callback. It is used across all the auth providers,</li>   <li><code>onLogout</code>: On logout callback. It is used across all the auth providers,</li>   <li><code>onTxStarted</code>: On transactions started callback. It is used across all the auth providers. You can use the transaction payload's current state,</li>   <li><code>onTxSent</code>: On transactions sent callback. It is used across all the auth providers. The transaction sent, but not finalized on chain. You can get its hash at this point.</li>   <li><code>onTxFinalized</code>: On transactions finalized callback. It is used across all the auth providers. You can use the transaction payload's current state.</li>   <li><code>onTxError</code>: On transactions errors callback. You can catch errors and manage UI states.</li>   <li><code>onQrPending</code>: Qr element load pending callback</li>   <li><code>onQrLoaded</code>: QR element loaded callback</li> </ul> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;script type=\"module\">     import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      const initElven = async () => {       await ElvenJS.init(         {           apiUrl: 'https://devnet-api.multiversx.com',           chainType: 'devnet',           apiTimeout: 10000,           // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in           walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',           walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],           onLoginPending: () => { /* do something when login pending */ },           onLoggedIn: () => { /* do something when logged in */ },           onLogout: () => { /* do something when logged out */ },           onTxStarted: (tx) => { /* do something when transaction started */ },           onTxSent: (tx) => { /* do something when transaction was sent */ },           onTxFinalized: (tx) => { /* do something when transaction was finalized */ },           onTxError: (tx, error) => { /* do something when transaction error occured */ }           onQrPending: () => { /* do something when QR code element is loading */ };           onQrLoaded: () => { /* do something when QR code element is loaded */ };         }       );     }   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Login</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.login(loginMethod: LoginMethodsEnum, options?: LoginOptions) </code></pre> <p><strong>Typings</strong>:</p> <pre><code class=\"language-typescript\">enum LoginMethodsEnum {   ledger = 'ledger', // not implemented yet   mobile = 'mobile',   webWallet = 'web-wallet',   xAlias = 'x-alias',   browserExtension = 'browser-extension', }  interface LoginOptions {   qrCodeContainer?: string | HTMLElement;   callbackRoute?: string; } </code></pre> <p>One interface for logging in with all possible auth providers. It is the core functionality in Elven.js</p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>loginMethod</code>: one of five login methods (ledger, mobile, web-wallet, x-alias, browser-extension) (for now, four of them are implemented)</li>   <li><code>options</code> as options, you can pass the <code>token</code>, which is a unique string that can be used for signature generation and user verification. You can also define <code>qrCodeContainer</code>, the DOM element id or DOM element in which the mobile QR code will be displayed, and <code>callbackRoute</code> used for web-wallet.</li> </ul> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-login-extension\">Login with extension&#x3C;/button>   &#x3C;button id=\"button-login-mobile\">Login with xPortal&#x3C;/button>   &#x3C;div id=\"qr-code-container\">&#x3C;/div>    &#x3C;script type=\"module\">     import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // Initialization first (see above) ...          document       .getElementById('button-login-extension')       .addEventListener('click', async () => {         try {           await ElvenJS.login('browser-extension');         } catch (e) {           console.log(             'Login: Something went wrong, try again!', e?.message           );         }       });      document       .getElementById('button-login-mobile')       .addEventListener('click', async () => {         try {           await ElvenJS.login('mobile', {             // You can also use the DOM element here:              // qrCodeContainer: document.querySelector('#qr-code-container')             qrCodeContainer: 'qr-code-container',           });         } catch (e) {           console.log(             'Login: Something went wrong, try again!', e?.message           );         }       });      document       .getElementById('button-login-web')       .addEventListener('click', async () => {         try {           await ElvenJS.login('web-wallet', { callbackRoute: '/' });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      document       .getElementById('button-login-x-alias')       .addEventListener('click', async () => {         try {           await ElvenJS.login('x-alias', { callbackRoute: '/' });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Logout</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.logout() </code></pre> <p>Logout function will remove the localStorage entries. It will work the same with each auth provider.</p> <p><strong>No arguments</strong>.</p> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-logout\">Logout&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      document       .getElementById('button-logout')       .addEventListener('click', async () => {         try {           await ElvenJS.logout();         } catch (e) {           console.error(e.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Signing and sending transactions</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.signAndSendTransaction(transaction: Transaction) </code></pre> <p><strong>Typings</strong>:</p> <p><code>Transaction</code> is the sdk-js exported <a href=\"https://github.com/multiversx/mx-sdk-js-core/blob/main/src/transaction.ts\">Transaction</a> class.</p> <p>The sign and send transaction handle one transaction at a time. This is basic functionality that is enough in most cases. The previously prepared transaction instance will be signed and sent with that function. You will use your chosen provider (mobile app, browser extension, etc.) for signing.</p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>transaction</code>: the sdk-js transaction class, the transaction instance is the same as the sdk-js one.</li> </ul> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-tx\">Send transaction&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS,       Transaction,       Address,       TransactionPayload,       TokenTransfer     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      const egldTransferAddress = 'erd17a4wydhhd6t3hhssvcp9g23ppn7lgkk4g2tww3eqzx4mlq95dukss0g50f';      document       .getElementById('button-tx')       .addEventListener('click', async () => {         const demoMessage = 'Transaction demo from Elven.js!';          const isGuarded = ElvenJS.storage.get('activeGuardian');         // You will need additional 50000 when using guardians         const gasLimit = (isGuarded ? 100000 : 50000) + 1500 * demoMessage.length;          const tx = new Transaction({           nonce: ElvenJS.storage.get('nonce'),           receiver: new Address(egldTransferAddress),           gasLimit,           chainID: 'D',           data: new TransactionPayload(demoMessage),           value: TokenTransfer.egldFromAmount(0.001),           sender: new Address(ElvenJS.storage.get('address')),         });          try {           await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>You can also see the transaction instance here. There is a couple of classes exported from sdk-js. You can think of them as helper tools for data preparation. More about them later.</p> <h3>Querying a smart contract</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">// function await ElvenJS.queryContract(queryArgs: SmartContractQueryArgs) </code></pre> <p><strong>Typings</strong>:</p> <pre><code class=\"language-typescript\">interface QueryArguments {   func: IContractFunction;   args?: TypedValue[];   value?: ITransactionValue;   caller?: IAddress; }  interface SmartContractQueryArgs extends QueryArguments {   address: IAddress; } </code></pre> <p>   <code>QueryArguments</code> is the sdk-js exported <a href=\"https://github.com/multiversx/mx-sdk-js-core/blob/main/src/smartcontracts/interface.ts\">QueryArguments</a> type.   Querying smart contracts is possible with this function. You must pass the smart contract address, function name (smart contract endpoint), and arguments (if it takes any). The value and caller are optional. </p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>address</code> - <code>IAddress</code> interface from sdk-js, you will get it by <code>new Address(&#x3C;string_addres>)</code></li>   <li><code>func</code> - <code>IContractFunction</code> interface from sdk-js, you will get it by <code>new ContractFunction('&#x3C;function_name>')</code></li>   <li><code>args</code> - <code>TypedValue</code> array, you will get it by using one of many helpers like <code>U32Value</code>, <code>AddressValue</code>, <code>BytesValue</code>, etc. You'll learn more about it later</li>   <li><code>value</code> - the value to transfer. It is optional or can be set to 0</li>   <li><code>caller</code> - also <code>Iaddress</code> interface, the same as an address, also optional</li> </ul> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-tx\">Send transaction&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS,       Address,       AddressValue,       ContractFunction,     } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      // You can also use currently logged in user addres: ElvenJS.storage.get('address')     const randomUserAddress = \"erd1druav0mlt7wzutla33kw80ueaalmec7mz2hus5svdmzlfj286qpstg674t\";          document       .getElementById('button-query')       .addEventListener('click', async () => {         try {           const results = await ElvenJS.queryContract({             address: new Address(nftMinterSmartContract),             func: new ContractFunction('getMintedPerAddressTotal'),             args: [new AddressValue(new Address(randomUserAddress))]           });            // Manual decoding of a simple type (number here) with aa custom helper function,            // there will be additional tools for that           const hexVal = base64ToDecimalHex(results?.returnData?.[0]);           console.log(hexVal)         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Storage handling</h3> <pre><code class=\"language-typescript\">ElvenJS.storage.get(); // all keys ElvenJS.storage.get('address'); // single key ElvenJS.storage.set('address', 'erd1...'); // set the value for a key ElvenJS.storage.clear(); </code></pre> <p>Storage is a thin wrapper over the localStorage. All data required for synchronization on page refresh is kept there.</p> <p>Remember that it shouldn't be used as a custom localStorage operations replacement. It has preconfigured localStorage key and should be used only for ElvenJS related operations. Mostly reading the actual state of the application. Below you will find what data you can get:</p> <ul>   <li><code>signature</code> - auth signature when you provide the auth token</li>   <li><code>loginToken</code> - the token you pass in the login function to get the signature back (optional)</li>   <li><code>address</code> - actually logged in erd address</li>   <li><code>activeGuardian</code> - active guardian assigned for the address</li>   <li><code>loginMethod</code> - actually chosen login method, for example, <code>browser-extension</code></li>   <li>     <code>expires</code> - when your current session will expire     <code>balance</code> - your actual Egld balance   </li>   <li><code>nonce</code> - your actual nonce - this one is quite important because you will need it when preparing transactions objects</li> </ul> <p>Example of the localStorage data:</p> <pre><code class=\"language-json\">{   \"signature\":\"42946a91f332eb3e413bc7ac18b8246bca1cb230ef2813ed714cd0417c95a8eb8104ce4e7d7c9ce1fb03853e10e7817416f8a8e789111df89909cd973f41ee0b\",   \"address\":\"erd1druav0mlt7wzutla33kw80ueaalmec7mz2hus5svdmzlfj286qpstg674t\",   \"activeGuardian\": \"erd1cscs8styv2ahllym0twsanezd4v65mcf5fungfvazgsfmuhwlehstadanq\",   \"loginMethod\":\"browser-extension\",   \"expires\":1663881876868,   \"nonce\":166,   \"balance\":\"6089909418940000000\" } </code></pre> <p>The storage key is <code>elvenjs_state</code>.</p> <h3>Destroy and cleanup</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">ElvenJS.destroy() </code></pre> <p>Mostly helpful in single-page applications where you would like to do some cleanup when you don't need the ElvenJS instance anymore.</p> <p><strong>No arguments</strong>.</p> <h3>Exported classes and types from sdk-js</h3> <p>Below is the list of exported helpers, classes, and types from sdk-js. You can read more about them in the <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/sdk-js-cookbook\">sdk-js cookbook</a>, also please check the <a href=\"/docs/recipes.html\">recipes</a> section, where you will find some of the use cases related to these:</p> <ul>   <li><code>TokenTransfer</code></li>   <li><code>TransferTransactionsFactory</code></li>   <li><code>GasEstimator</code></li>   <li><code>Address</code></li>   <li><code>Account</code></li>   <li><code>Transaction</code></li>   <li><code>TransactionPayload</code></li>   <li><code>TransactionWatcher</code></li>   <li><code>SmartContract</code></li>   <li><code>ContractFunction</code></li>   <li><code>BytesType</code></li>   <li><code>BytesValue</code></li>   <li><code>U16Type</code></li>   <li><code>U16Value</code></li>   <li><code>U32Type</code></li>   <li><code>U32Value</code></li>   <li><code>U64Type</code></li>   <li><code>U64Value</code></li>   <li><code>U8Type</code></li>   <li><code>U8Value</code></li>   <li><code>BigUIntType</code></li>   <li><code>BigUIntValue</code></li>   <li><code>BooleanType</code></li>   <li><code>BooleanValue</code></li>   <li><code>AddressType</code></li>   <li><code>AddressValue</code></li> </ul> <p>You can import them directly from elven.js without the ElvenJS namespace. Like:</p> <pre><code class=\"language-typescript\">import {   Address,   ContractCallPayloadBuilder,   ContractFunction } from 'https://unpkg.com/elven.js@0.13.0/build/elven.js'; </code></pre> <p>There will probably be more of them, but the ElvenJS library should be as small as possible. Maybe some of them will land in separate libraries like the planned query results parser library.</p> <h3>Summary</h3> <p>You learned about all functions from ElvenJS. The library will undoubtedly get some more functionality in the future, but for now, this is enough to let you build dApps and widgets on your existing websites.</p> <p>Please check the <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">JS SDK</a> tools for more info on some of the types and classes described here, and for sure, reading the <a href=\"/docs/recipes.html\">recipes</a> section will be beneficial.</p>","excerpt":"Elven.js - the JavaScript SDK for the MultiversX blockchain. Compact and simplified wrapper for sdk-js!","publicationDate":"2022-09-20","tags":["intro"],"coverImage":""}]