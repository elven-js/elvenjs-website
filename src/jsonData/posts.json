[{"fileName":"getting-started.html","title":"Getting started","body":"<p>Elven.js is a tool designed to work in browsers without any build steps and integrate MultiversX blockchain and smart contracts built on it.</p> <p>The tool is a wrapper for <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">sdk-js</a> - a set of Typescript/Javascript libraries. But because the sdk-js toolset is quite extensive and has a lot of Node module dependencies, there is a need for a simple browser-only library. The Elven.js aspire to be something like that - a helpful plug-and-play solution that will give you the most basic functionalities.</p> <div class=\"docs-box docs-info-box\">The quickest way to learn how to use elven.js is to check the source code of the simple example: <a href=\"https://elvenjs.netlify.app/\" target=\"_blank\">elvenjs.netlify.app</a></div> <h2>What Elven.js can do?</h2> <p>The fundamental functionality is connecting and logging in the user using auth providers. For now, Elven.js supports three of four existing - The MultiversX <a href=\"https://chrome.google.com/webstore/detail/multiversx-defi-wallet/dngmlblcodfobpdpecaadgfbcggfjfnm\">browser extension</a> (MultiversX Defi), <a href=\"https://xportal.com/\">xPortal Mobile app</a>, and MultiversX Web Wallet. In the future, it will also support <a href=\"https://www.ledger.com/\">Ledger Nano</a> hardware wallet. It also supports <a href=\"https://xportal.com/\">xPortal</a> Hub integration and <a href=\"https://xalias.com/\">xAlias</a>.</p> <p>So basically, the user can attach the Elven.js script and start authenticating users on the front end. There is also an option to pass a unique token and get a signature after authentication, which you can use for additional backend verification. You will read more about it in the <a href=\"/docs/recipes.html\">recipes</a> section.</p> <p>Besides authentication, Elven.js will also help with all the interactions, like sending native $EGLD tokens or even ESDT tokens. It will allow you to make most transactions, including interactions with custom smart contracts. It allows to sign custom messages. There is also a possibility to query smart contracts. For now, you need to decode the returned data using custom logic, but there will be a separate utility soon.</p> <h2>How is Elven.js built?</h2> <p>In the end, the Elven.js library is a simple browser-based JS script. You can copy it from the repository and use it as a local JavaScript file or import it directly from the CDN.</p> <p>The script is a wrapper for sdk-js, an official JavaScript SDK for usage in the Nodejs ecosystem. JS SDK can also be used in the browser but requires additional build steps and configuration, and the file itself will be huge. This is why Elven.js exists.</p> <p>Elven.js imports only crucial parts of the sdk-js libraries. It will include the most used parts of the sdk-js, which are essential for the browsers. All other functionality will be split into separate scripts, and it will be shipped as optional scripts in the future.</p> <p>Internally Elven.js uses Typescript, but finally, it is a standard minified JavaScript file. It can be used in static websites and frameworks like React, SolidJS, or Vue. It is worth mentioning that there are official tools for React already, so it will probably be a better choice to check them. You could also check the <a href=\"https://github.com/xdevguild/nextjs-dapp-template\">MultiversX NextJs dApp template</a>.</p> <h2>How to start using it?</h2> <p>Because Elven.js is just a JavaScript file, you can import it from CDN and start using its inner parts. You can also copy the file version from the <a href=\"https://github.com/elven-js/elven.js/tree/main/build\">build</a> directory in the repository.</p> <p>Let's see how to import it from the CDN:</p> <pre><code class=\"language-html\">&#x3C;html>   &#x3C;body>     &#x3C;script type=\"module\">       import { ElvenJS } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';        const initElven = async () => {         await ElvenJS.init(           {             apiUrl: 'https://devnet-api.multiversx.com',             chainType: 'devnet',             apiTimeout: 10000,             // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in             walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',             walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],             onLoginStart: () => {},             onLoginSuccess: () => {},             onLoginFailure: (error) => {},             onLogoutStart: () => {},             onLogoutSuccess: () => {},             onLogoutFailure: (error) => {},             onTxStart: (tx) => {},             onTxSent: (tx) => {},             onTxFinalized: (tx) => {},             onTxFailure: (tx, error) => {},             onQrPending: () => {},             onQrLoaded: () => {},             onSignMsgStart: (message) => {},             onSignMsgFinalized: (message, messageSignature) => {},             onSignMsgFailure: (message, error) => {},             onQueryStart: (queryArgs) => {},             onQueryFinalized: (queryResponse) => {},             onQueryFailure: (queryArgs, error) => {}           }         );       }        initElven();     &#x3C;/script>   &#x3C;/body> &#x3C;/html> </code></pre> <p>As you can see here, we have a simplified HTML document where we import the Elven.js SDK parts. Always check the version number (the example from here is v0.17.0: <code>elven.js@0.17.0</code>).</p> <p>You can check the demo examples linked on the homepage.</p> <p>If you work with a frontend framework for which no tools support the MultiversX blockchain, you can also use the Elven.js tools, installing them as a dependency and then importing from it.</p> <pre><code class=\"language-bash\">npm install elven.js --save </code></pre> <p>Example with SolidJs:</p> <pre><code class=\"language-typescript\">import { ElvenJS } from 'elven.js';  (...)  onMount(() => {   const initElven = async () => {     await ElvenJS.init({       apiUrl: 'https://devnet-api.multiversx.com',       chainType: 'devnet',       apiTimeout: 10000,       // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in       walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',       walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],       onLoginStart: () => {},       onLoginSuccess: () => {},       onLoginFailure: (error) => {},       onLogoutStart: () => {},       onLogoutSuccess: () => {},       onLogoutFailure: (error) => {},       onTxStart: (tx) => {},       onTxSent: (tx) => {},       onTxFinalized: (tx) => {},       onTxFailure: (tx, error) => {},       onQrPending: () => {},       onQrLoaded: () => {},       onSignMsgStart: (message) => {},       onSignMsgFinalized: (message, messageSignature) => {},       onSignMsgFailure: (message, error) => {},       onQueryStart: (queryArgs) => {},       onQueryFinalized: (queryResponse) => {},       onQueryFailure: (queryArgs, error) => {}     });   };    initElven(); });  (...) </code></pre> <p>Because of the ability to adapt to any frontend framework Elven.js is an excellent choice for all widget-like implementations. Imaging WordPress or Shopify plugins with it. Or, for example, simple donation widgets for static hobby websites. You can find such an example here: <a href=\"https://elrond-donate-widget-demo.netlify.app/\">elrond-donate-widget-demo.netlify.app</a>.</p> <h2>Demo videos</h2> <div class=\"embeded-media-two-cols\">   <div class=\"embeded-media-col\">     <div class=\"embed-media-header\">Connect and disconnect walkthrough video with comments.</div>     <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VKuid5hOkYg\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>   </div>   <div class=\"embeded-media-col\">     <div class=\"embed-media-header\">The video is a little bit outdated. Check the version and <a href=\"https://github.com/elven-js/elven.js/blob/main/CHANGELOG.md\" target=\"_blank\">changelog</a>.</div>     <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/tcTukpkjcQw\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>   </div> </div> <h2>Summary</h2> <p>Okay, so you know what Elven.js is and how to start using it. You are now ready to look at the <a href=\"/docs/sdk-reference.html\">SDK reference</a> and <a href=\"/docs/recipes.html\">recipes</a>.</p> <p>Also, there are a lot of links to the demo applications on the homepage, so you could also check the code of each one.</p>","excerpt":"Elven.js - the JavaScript SDK for the MultiversX blockchain. Compact and simplified wrapper for sdk-js!","publicationDate":"2022-09-20","tags":["intro"],"coverImage":""},{"fileName":"recipes.html","title":"Recipes","body":"<p>In this section, we will check real-world examples. Of course, you can also check the code in many demos linked on the homepage. Let's see the most common cases here.</p> <p>Remember that you can use the ElvenJS not only in static websites but let's focus only on such ones for simplicity. Check the linked demos on StackBlitz to learn how to use it, for example, with Vue or SolidJS.</p> <h3>How to login and logout with auth providers</h3> <p>ElvenJS offers two of four auth providers for now. They are the <a href=\"https://xportal.com/\">xPortal Mobile app</a>, <a href=\"https://chrome.google.com/webstore/detail/multiversx-defi-wallet/dngmlblcodfobpdpecaadgfbcggfjfnm\">MultiversX browser extension</a>, and MultiversX Web Wallet. There will also be support for the <a href=\"https://www.ledger.com/\">Ledger Nano</a> and Ledger Nano.</p> <p>To be able to login you need to initialize ElvenJs and then use the login function:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-login-extension\" style=\"display: none;\">Login with Extension&#x3C;/button>   &#x3C;button class=\"button\" id=\"button-login-mobile\" style=\"display: none;\">Login     with xPortal&#x3C;/button>   &#x3C;button class=\"button\" id=\"button-logout\" style=\"display: none;\">Logout&#x3C;/button>    &#x3C;div id=\"qr-code-container\" class=\"qr-code-container\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiLoggedInState,       uiPending,     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       // Check all possible InitOptions at https://www.elvenjs.com/docs/sdk-reference.html#initialization       await ElvenJS.init(...);     }      // Trigger the async init function      initElven();      // Add event listener for extension login button      document       .getElementById('button-login-extension')       .addEventListener('click', async () => {         try {           await ElvenJS.login('browser-extension');         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      // Add event listener for mobile login button      // You will need a container for the qr code     document       .getElementById('button-login-mobile')       .addEventListener('click', async () => {         try {           await ElvenJS.login('mobile', {             // You can also use the DOM element here:              // qrCodeContainer: document.querySelector('#qr-code-container')             qrCodeContainer: 'qr-code-container',           });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      // Add event listener for web login button      // You can pass the callback url - the landing page after login on web wallet website     document       .getElementById('button-login-web')       .addEventListener('click', async () => {         try {           await ElvenJS.login('web-wallet', { callbackRoute: '/' });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      // Add event listener for logout button     document       .getElementById('button-logout')       .addEventListener('click', async () => {         try {           // Trigger the ElvenJS logout           const isLoggedOut = await ElvenJS.logout();         } catch (e) {           console.error(e.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>After using one of the login methods, your data will be kept in the localStorage for further usage and synchronization. No worries, nothing private.</p> <p>From now on, you can sign and send transactions.</p> <h3>How to send EGLD</h3> <p>For this example, let's omit the code responsible for initialization and auth. You can check it above. Let's focus on the EGLD operations:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-tx\" style=\"display: none;\">EGLD transaction&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Transaction,       Address,       TransactionPayload,       TokenTransfer     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       // Check all possible InitOptions at https://www.elvenjs.com/docs/sdk-reference.html#initialization       await ElvenJS.init(...);     }      // Trigger the async init function      initElven();      const egldTransferAddress = 'erd17a4wydhhd6t3hhssvcp9g23ppn7lgkk4g2tww3eqzx4mlq95dukss0g50f';      // Event listener for predefined EGLD transaction     document       .getElementById('button-tx')       .addEventListener('click', async () => {         updateTxHashContainer(false);         const demoMessage = 'Transaction demo from Elven.js!';          const isGuarded = ElvenJS.storage.get('activeGuardian');                  // predefined transaction, this is how it is usually built         const tx = new Transaction({           // Get the actal nonce from storage           nonce: ElvenJS.storage.get('nonce'),           // Get the receiver of the EGLD           receiver: new Address(egldTransferAddress),           // Calculate gas limit (check MultiversX docs)           // You will need additional 50000 when using guardians           gasLimit: (isGuarded ? 100000 : 50000) + 1500 * demoMessage.length,           // Define the chain id (D for the devnet, T for the testnet, 1 for the mainnet)           chainID: 'D',           // Build transaction payload data, here very simple string           data: new TransactionPayload(demoMessage),           // EGLD value to send           value: TokenTransfer.egldFromAmount(0.001),           // Your address, we can get it from the storage, because you should be loggedin           sender: new Address(ElvenJS.storage.get('address')),         });          try {           // Send the transaction           await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>As you can see, more logic is involved in building the transaction here. It could look not very easy, but generally, it is just an object created with a couple of helpers exported from sdk-js SDK. So it is very similar to how you would do this with sdk-js.</p> <p>Transactions are handled in very similar ways. They only need different payload structures and builders. You will find the whole list of them in the <a href=\"/docs/sdk-reference.html\">SDK reference</a>.</p> <p>Oh, and by the way, the transaction here is predefined, but you could have your logic that could take all the values from some form, user action etc.</p> <h3>How to send ESDT</h3> <p>The same here. Let's not focus on initialization and login. You can check it above in the first point.</p> <p>Below you will find an example of the ESDT transfer. What is ESDT? These are tokens on the MultiversX network that you can create for yourself. Please read more about them <a href=\"https://docs.multiversx.com/tokens/esdt-tokens/\">here</a>.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-tx-esdt\" style=\"display: none;\">ESDT transaction*&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,       updateQueryResultContainer     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Address,       TokenTransfer,       TransferTransactionsFactory,       GasEstimator,     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       // Check all possible InitOptions at https://www.elvenjs.com/docs/sdk-reference.html#initialization       await ElvenJS.init(...);     }      // Trigger the async init function      initElven();      // ESDT address for demo purpose     const esdtTransferAddress = 'erd17a4wydhhd6t3hhssvcp9g23ppn7lgkk4g2tww3eqzx4mlq95dukss0g50f';      // Event listener for triggering the predefined ESDT transaction     document       .getElementById('button-tx-esdt')       .addEventListener('click', async () => {         updateTxHashContainer(false);          // We need to build the payment here, we need to provide some data         // Token id, amount and decimal places (check sdk-js cookbook for more info)         const payment = TokenTransfer.fungibleFromAmount(           'BUILDO-890d14',           '1',           18         );          // Here we are preparing the transfer factory         // We use default GasEstimator - this way we don't have to worry about providing gas limit vale         const factory = new TransferTransactionsFactory(new GasEstimator());          // And here we have actual transaction         // It doesn't need the value field, because we don't send the EGLD         const tx = factory.createESDTTransfer({           tokenTransfer: transfer,           receiver: new Address(esdtTransferAddress),           sender: new Address(ElvenJS.storage.get('address')),           chainID: 'D',         });          try {           // We use the same function as previously           const transaction = await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>How to mint NFT</h3> <p>Again, let's not focus on initialization and login. Check these above in the first point.</p> <p>Here we will mint an NFT on the <a href=\"https://www.elven.tools\">Elven Tools Minter Smart Contract</a> deployed on the devnet.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-mint\" style=\"display: none;\">Mint NFT&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,       updateQueryResultContainer     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Transaction,       Address,       TokenTransfer,       SmartContract,       ContractFunction,       U32Value,     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       // Check all possible InitOptions at https://www.elvenjs.com/docs/sdk-reference.html#initialization       await ElvenJS.init(...);     }      // Trigger the async init function      initElven();      // Here is the Elven Tools demo minter smart contract on the devnet     // The one we will be calling to mint the NFT     const nftMinterSmartContract = 'erd1qqqqqqqqqqqqqpgq5za2pty2tlfqhj20z9qmrrpjmyt6advcgtkscm7xep';          // We need an event to trigger the mint     document       .getElementById('button-mint')       .addEventListener('click', async () => {         updateTxHashContainer(false);          // Again, we are preparing the data payload using different helpers         // The function on smart contract is called 'mint'         // It also takes one argument which is the amount to mint         const contractAddress = new Address(nftMinterSmartContract);         const contract = new SmartContract({ address: contractAddress });          const isGuarded = ElvenJS.storage.get('activeGuardian');          const tx = contract.call({           caller: new Address(ElvenJS.storage.get('address')),           value: TokenTransfer.egldFromAmount(0.01),           func: new ContractFunction(\"mint\"),           // You need 50000 more when using guardians           gasLimit: isGuarded ?  : 14050000 ? 14000000,           args: [new U32Value(1)],           chainID: \"D\"         })          try {           // We still use the same ElvenJS function for that,            // only the transaction instance is different           const transaction = await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>You can check more about the NFT tokens on the MultiversX blockchain in the docs <a href=\"https://docs.multiversx.com/tokens/nft-tokens/\">here</a>. Also, check the <a href=\"https://www.elven.tools\">Elven Tools</a> if you want to run your own PFP NFT collection on the MultiversX blockchain. Free and open source smart contract, CLI tool, and dApp template.</p> <h3>How to sign a custom message</h3> <p>You can sign a message using your address as the key. But you don't have to worry about internals here. There is one function for that where you need to provide the message.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-tx\">Sign a message&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS,     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       // Check all possible InitOptions at https://www.elvenjs.com/docs/sdk-reference.html#initialization       await ElvenJS.init(...);     }      // Trigger the async init function      initElven();      document       .getElementById('button-tx')       .addEventListener('click', async () => {         try {           await ElvenJS.signMessage('Elven Family is awesome!');         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>How to verify a custom message on backend</h3> <p>For that you can use <code>UserVerifier</code> from <code>@multiversx/sdk-wallet</code> and <code>SignableMessage</code> from <code>@multiversx/sdk-core</code>.</p> <pre><code class=\"language-ts\">import { UserVerifier } from \"@multiversx/sdk-wallet\"; import { SignableMessage } from \"@multiversx/sdk-core\";  const userVerifier = UserVerifier.fromAddress(addressOfUser); const message = new SignableMessage({ message: Buffer.from(\"hello\") }); const serializedMessage = message.serializeForSigning(); const messageSignature = Buffer.from(\"{signature_hex_here}\", \"hex\");  userVerifier.verify(serializedMessage, messageSignature) </code></pre> <p>You can also use other SDKs. For example <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-py/\">sdk-py</a>.</p> <h3>How to query a smart contract</h3> <p>Smart contracts can offer read-only endpoints/functions that you can query. Let's omit the initialization and login using ElvenJS here. Check it in the first point.</p> <p>We will query the minter smart contract to get the number of NFTs already minted by the wallet address. Such a functionality is programmed in the Elven Tools Smart Contract, and everyone can do the query.</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button class=\"button\" id=\"button-query\" style=\"display: none;\">Query SC&#x3C;/button>   &#x3C;div id=\"tx-hash-or-query-result\" class=\"tx-hash-or-query-result\">&#x3C;/div>    &#x3C;script type=\"module\">     // Just for the demo - helpers     import {       uiPending,       updateTxHashContainer,       updateQueryResultContainer     } from './demo-ui-tools.js'      // import ElvenJS parts from CDN      import {       ElvenJS,       Address,       AddressValue,       ContractFunction,     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Init ElvenJs      const initElven = async () => {       // Check all possible InitOptions at https://www.elvenjs.com/docs/sdk-reference.html#initialization       await ElvenJS.init(...);     }      // Trigger the async init function      initElven();      // Here the same minter smart contract address as above. We will qery its function     const nftMinterSmartContract = 'erd1qqqqqqqqqqqqqpgq5za2pty2tlfqhj20z9qmrrpjmyt6advcgtkscm7xep';          document       .getElementById('button-query')       .addEventListener('click', async () => {         try {           updateQueryResultContainer();           uiPending(true);            // Here we use the queryContract function from ElvenJS           // we need to pass required values           const results = await ElvenJS.queryContract({             address: new Address(nftMinterSmartContract),             // The function on smart contract is called 'getMintedPerAddressTotal'             func: new ContractFunction('getMintedPerAddressTotal'),             // As an argument we need to pass our address to check in TypedValue type             // Check whole list in the SDK reference section             args: [new AddressValue(new Address(ElvenJS.storage.get('address')))]           });            uiPending(false);            // Manual decoding of a simple type (number here),            // there will be additional tools for that           // We know that it should be a number, so we can simply decode it using           // helper functions like base64 to decimal hex           // and then parse the hex number           // You'll find an example of such helper tool in the example directory in the repository           const hexVal = base64ToDecimalHex(results?.returnData?.[0]);           updateQueryResultContainer(`➡️ The result of the query is: ${parseInt(hexVal, 16)}`);         } catch (e) {           uiPending(false);           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>How to verify the user on the backend side</h3> <div class=\"docs-box docs-info-box\">You don't need to worry about this section if you don't plan to do any verification on the backend side of your application.</div> <p>By default elven.js uses <a href=\"https://www.npmjs.com/package/@multiversx/sdk-native-auth-client\">@multiversx/sdk-native-auth-client</a> under the hood.</p> <p>When logging in using one of the signing providers, a <code>loginToken</code> will be generated for you. It will then be used to acquire the signature. All with your account address will be then used to create <code>accessToken</code>. With that token, you can verify the user on the backend side, for example, using <a href=\"https://www.npmjs.com/package/@multiversx/sdk-native-auth-server\">@multiversx/sdk-native-auth-server</a>.</p> <h3>Transactions states and execution flow</h3> <p>When you use <code>ElvenJS.signAndSendTransaction</code>, a couple of callbacks will be called (You can define them in the <code>ElvenJS.init</code>), depending on the progress of current transactions.</p> <p>These are:</p> <ul>   <li><code>onTxStart?: (transaction: Transaction) => void;</code></li>   <li><code>onTxSent?: (transaction: Transaction) => void;</code></li>   <li><code>onTxFinalized?: (transaction: Transaction) => void;</code></li>   <li><code>onTxFailure?: (transaction: Transaction, error: string) => void;</code></li> </ul> <p>They are self-explanatory. <code>onTxSent</code> will fire after sending (the transaction object will not contain the signature yet). The <code>onTxFinalized</code> will fire after the transaction is finalized on chain (the transaction object will contain the signature).</p> <p>In case of the error, the <code>onTxFailure</code> will additionally contain the error message.</p> <h3>Styling elements</h3> <p>There are a couple of elements that use external styles. Feel free to copy styles if needed. You can check the examples in the <code>example</code> directory.</p> <p>No styles are attached to QR code elements and WalletConnect pairings list by default. But each piece has CSS classes that you can use.</p> <p>The list of classes:</p> <ul>   <li><code>.elven-qr-code-deep-link</code></li>   <li><code>.elven-wc-pairings</code></li>   <li><code>.elven-wc-pairings-header</code></li>   <li><code>.elven-wc-pairing-item</code></li>   <li><code>.elven-wc-pairings-remove-btn</code></li>   <li><code>.elven-wc-pairing-item-description</code></li>   <li><code>.elven-wc-pairing-item-confirm-msessage</code></li> </ul> <p>For more info, check the demo in the <code>example</code> directory. Please let us know if you need more styling flexibility and options. Describe your use cases <a href=\"https://github.com/elven-js/elven.js/issues\">here</a>.</p> <h3>xPortal Hub integration</h3> <p>The Elven.js dApps can integrate with the xPortal Hub. You can read more on how to get your app accepted <a href=\"https://multiversx.notion.site/How-to-submit-your-dApp-for-listing-in-the-xPortal-Hub-863f1005a56943fba38c0e0cb5b1186a\">here</a>.</p> <p>You don't have to do anything. It should just work when your app is accepted and published in the xPortal Hub.</p> <h3>Working demos</h3> <p>The demos are linked on the homepage, but let's bring them also here:</p> <ul>   <li><a href=\"https://elvenjs.netlify.app/\">elvenjs.netlify.app</a> - EGLD, ESDT transactions, smart contract queries and transactions</li>   <li><a href=\"https://elrond-donate-widget-demo.netlify.app/\">elrond-donate-widget-demo.netlify.app</a> - donation-like widget demo</li>   <li><a href=\"https://stackblitz.com/edit/web-platform-d4rx5v?file=index.html\">StackBlitz vanilla html demo</a></li>   <li><a href=\"https://stackblitz.com/edit/vitejs-vite-rbo6du?file=src/App.tsx\">StackBlitz Solid.js demo</a></li>   <li><a href=\"https://stackblitz.com/edit/vitejs-vite-qr2u7l?file=src/App.tsx\">StackBlitz React demo</a></li>   <li><a href=\"https://stackblitz.com/edit/vue-zrb8y5?file=src/App.vue\">StackBlitz Vue demo</a></li> </ul> <p>You should be able to find the source code of each under the links.</p>","excerpt":"Elven.js - the JavaScript SDK for the MultiversX blockchain. Compact and simplified wrapper for sdk-js!","publicationDate":"2022-09-19","tags":["intro"],"coverImage":""},{"fileName":"sdk-reference.html","title":"SDK Reference","body":"<p>The Elven.js tool will be as simple as possible. It exports a couple of helper functions. It also exports several data structures (types) from <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">sdk-js</a> libraries. Here you will find a description of all the parts, and then you can check the <a href=\"/docs/recipes.html\">recipes</a> section for real-world examples.</p> <p>Worth mentioning. Remember to check the source code, written in Typescript. You will find all the source files here: <a href=\"https://github.com/elven-js/elven.js/tree/main/src\">elven.js/src</a>.</p> <h3>Initialization</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.init(initOptions: InitOptions) </code></pre> <p><strong>Typings</strong>:</p> <pre><code class=\"language-typescript\">interface InitOptions {   apiUrl?: string;   chainType?: string;   apiTimeout?: number;   walletConnectV2ProjectId?: string;   walletConnectV2RelayAddresses?: string[];   // Login   onLoginStart?: () => void;   onLoginSuccess?: () => void;   onLoginFailure?: (error: string) => void;   // Logout   onLogoutStart?: () => void;   onLogoutSuccess?: () => void;   onLogoutFailure?: (error: string) => void;   // Qr   onQrPending?: () => void;   onQrLoaded?: () => void;   // Transaction   onTxStart?: (transaction: Transaction) => void;   onTxSent?: (transaction: Transaction) => void;   onTxFinalized?: (transaction: Transaction) => void;   onTxFailure?: (transaction: Transaction, error: string) => void;   // Signing   onSignMsgStart?: (message: string) => void;   onSignMsgFinalized?: (messageSignature: string) => void;   onSignMsgFailure?: (message: string, error: string) => void;   // Query   onQueryStart?: (queryArgs: QueryArguments) => void;   onQueryFinalized?: (queryResponse: ContractQueryResponse) => void;   onQueryFailure?: (queryArgs: QueryArguments, error: string) => void; } </code></pre> <p>The primary initialization function. It is responsible for synchronizing with the MultiversX network and attaching login/logout callbacks.</p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>apiUrl</code>: MultiversX API URL - can be the public or private instance,</li>   <li><code>chainType</code>: Chain type identification - can be devnet, testnet, or mainnet,</li>   <li><code>apiTimeout</code>: The API call timeout in milliseconds. Maximum 10000,</li>   <li><code>walletConnectV2ProjectId</code>: Get yours from https://cloud.walletconnect.com/sign-in,</li>   <li><code>walletConnectV2RelayAddresses</code>: You can pass your custom WalletConnect relay adresses, by default it will use 'wss://relay.walletconnect.com'</li>   <li><code>onLoginStart</code>: Triggered when the login process started</li>   <li><code>onLoginSuccess</code>: Triggered when the login process is successful</li>   <li><code>onLoginFailure</code>: Triggered when the login process failed</li>   <li><code>onLogoutStart</code>: Triggered when the logout process started</li>   <li><code>onLogoutSuccess</code>: Triggered when the logout process is successful</li>   <li><code>onLogoutFailure</code>: Triggered when the logout process failed</li>   <li><code>onQrPending</code>: Triggered when the Qr element started loading</li>   <li><code>onQrLoaded</code>: Triggered when the QR element finished loading</li>   <li><code>onTxStart</code>: Triggered when the transaction process started</li>   <li><code>onTxSent</code>: Triggered when the transaction is send, not finalized</li>   <li><code>onTxFinalized</code>: Triggered when the transaction is finalized</li>   <li><code>onTxFailure</code>: Triggered when the transaction sign and send filed</li>   <li><code>onSignMsgStart</code>: Triggered when the message signing process stated</li>   <li><code>onSignMsgFinalized</code>: Triggered when the message signing process finalized</li>   <li><code>onSignMsgFailure</code>: Triggered when the message signing process failed</li>   <li><code>onQueryStart</code>: Triggered when the query process started</li>   <li><code>onQueryFinalized</code>: Triggered when the query process finalized</li>   <li><code>onQueryFailure</code>: Triggered when the query process failed</li> </ul> <p>You can import required types directly from elven.js</p> <pre><code class=\"language-typescript\">import {   Transaction,   QueryArguments,   ContractQueryResponse } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js'; </code></pre> <p>   <strong>Usage example</strong>:   The <a href=\"https://elvenjs.netlify.app/\">demo example</a> initialization code. </p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;script type=\"module\">     import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      const initElven = async () => {       await ElvenJS.init(         {           apiUrl: 'https://devnet-api.multiversx.com',           chainType: 'devnet',           apiTimeout: 10000,           // Remember to change it. Get yours here: https://cloud.walletconnect.com/sign-in           walletConnectV2ProjectId: '&#x3C;your_wc_project_id_here>',           walletConnectV2RelayAddresses: ['wss://relay.walletconnect.com'],           // All callbacks are optional           // You could also rely on try catch to some extent, but callbacks in one place seems convenient           // Login callbacks:           onLoginStart: () => { uiPending(true) },           onLoginSuccess: () => { uiLoggedInState(true); },           onLoginFailure: (error) => { displayError(error); },           // Logout callbacks:           onLogoutStart: () => { uiPending(true) },           onLogoutSuccess: () => { uiLoggedInState(false); },           onLogoutFailure: (error) => { displayError(error); },           // Transaction callbacks           onTxStart: (tx) => { uiPending(true); },           onTxSent: (tx) => { const hash = tx.getHash().toString(); hash &#x26;&#x26; updateTxHashContainer(hash, true); },           onTxFinalized: (tx) => { tx?.hash &#x26;&#x26; updateTxHashContainer(tx.hash); uiPending(false); },           onTxFailure: (tx, error) => { displayError(error); uiPending(false); },           // Qr code callbacks:           onQrPending: () => { uiPending(true); },           onQrLoaded: () => { uiPending(false); },           // Signing callbacks:           onSignMsgStart: (message) => { uiPending(true); },           onSignMsgFinalized: (message, messageSignature) => { messageSignature &#x26;&#x26; updateOperationResultContainer(`➡️ The signature for \"${message}\" message:\\n${messageSignature}`); uiPending(false); },           onSignMsgFailure: (message, error) => { displayError(error); uiPending(false); },           // Query callbacks:           onQueryStart: (queryArgs) => { uiPending(true); },           onQueryFinalized: (queryResponse) => {             // Manual decoding of a simple type (number here), there will be additional tools for that using ABI             // For now please check data converter in Buildo.dev:              // https://github.com/xdevguild/buildo.dev/blob/main/components/operations/utils-operations/data-converters.tsx#L103             const hexVal = base64ToDecimalHex(queryResponse?.returnData?.[0]);             let intVal = 0;             if (hexVal) {               intVal = parseInt(hexVal, 16);             }             updateOperationResultContainer(`➡️ The result of the query is: ${intVal}`);             uiPending(false);           },           onQueryFailure: (queryArgs, error) => { displayError(error); uiPending(false); }         }       );     }   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Login</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.login(loginMethod: LoginMethodsEnum, options?: LoginOptions) </code></pre> <p><strong>Typings</strong>:</p> <pre><code class=\"language-typescript\">enum LoginMethodsEnum {   ledger = 'ledger', // not implemented yet   mobile = 'mobile',   webWallet = 'web-wallet',   xAlias = 'x-alias',   browserExtension = 'browser-extension', }  interface LoginOptions {   qrCodeContainer?: string | HTMLElement;   callbackRoute?: string; } </code></pre> <p>One interface for logging in with all possible auth providers. It is the core functionality in Elven.js</p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>loginMethod</code>: one of five login methods (ledger, mobile, web-wallet, x-alias, browser-extension) (for now, four of them are implemented)</li>   <li><code>options</code> as options, you can pass the <code>token</code>, which is a unique string that can be used for signature generation and user verification. You can also define <code>qrCodeContainer</code>, the DOM element id or DOM element in which the mobile QR code will be displayed, and <code>callbackRoute</code> used for web-wallet.</li> </ul> <p><strong>Initialization callbacks</strong><br>Callbacks that will be triggered for that function</p> <pre><code class=\"language-typescript\">onLoginStart?: () => void; onLoginSuccess?: () => void; onLoginFailure?: (error: string) => void; </code></pre> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-login-extension\">Login with extension&#x3C;/button>   &#x3C;button id=\"button-login-mobile\">Login with xPortal&#x3C;/button>   &#x3C;div id=\"qr-code-container\">&#x3C;/div>    &#x3C;script type=\"module\">     import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Initialization first (see above) ...          document       .getElementById('button-login-extension')       .addEventListener('click', async () => {         try {           await ElvenJS.login('browser-extension');         } catch (e) {           console.log(             'Login: Something went wrong, try again!', e?.message           );         }       });      document       .getElementById('button-login-mobile')       .addEventListener('click', async () => {         try {           await ElvenJS.login('mobile', {             // You can also use the DOM element here:              // qrCodeContainer: document.querySelector('#qr-code-container')             qrCodeContainer: 'qr-code-container',           });         } catch (e) {           console.log(             'Login: Something went wrong, try again!', e?.message           );         }       });      document       .getElementById('button-login-web')       .addEventListener('click', async () => {         try {           await ElvenJS.login('web-wallet', { callbackRoute: '/' });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });      document       .getElementById('button-login-x-alias')       .addEventListener('click', async () => {         try {           await ElvenJS.login('x-alias', { callbackRoute: '/' });         } catch (e) {           console.log('Login: Something went wrong, try again!', e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Logout</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.logout() </code></pre> <p>Logout function will remove the localStorage entries. It will work the same with each auth provider.</p> <p><strong>No arguments</strong>.</p> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-logout\">Logout&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      document       .getElementById('button-logout')       .addEventListener('click', async () => {         try {           await ElvenJS.logout();         } catch (e) {           console.error(e.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p><strong>Initialization callbacks</strong><br>Callbacks that will be triggered for that function</p> <pre><code class=\"language-typescript\">onLogoutStart?: () => void; onLogoutSuccess?: () => void; onLogoutFailure?: (error: string) => void; </code></pre> <h3>Signing and sending transactions</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.signAndSendTransaction(transaction: Transaction) </code></pre> <p><strong>Typings</strong>:</p> <p><code>Transaction</code> is the sdk-js exported <a href=\"https://github.com/multiversx/mx-sdk-js-core/blob/main/src/transaction.ts\">Transaction</a> class.</p> <p>The sign and send transaction handle one transaction at a time. This is basic functionality that is enough in most cases. The previously prepared transaction instance will be signed and sent with that function. You will use your chosen provider (mobile app, browser extension, etc.) for signing.</p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>transaction</code>: the sdk-js transaction class, the transaction instance is the same as the sdk-js one.</li> </ul> <p><strong>Initialization callbacks</strong><br>Callbacks that will be triggered for that function</p> <pre><code class=\"language-typescript\">onTxStart?: (transaction: Transaction) => void; onTxSent?: (transaction: Transaction) => void; onTxFinalized?: (transaction: Transaction) => void; onTxFailure?: (transaction: Transaction, error: string) => void; </code></pre> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-tx\">Send transaction&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS,       Transaction,       Address,       TransactionPayload,       TokenTransfer     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      const egldTransferAddress = 'erd17a4wydhhd6t3hhssvcp9g23ppn7lgkk4g2tww3eqzx4mlq95dukss0g50f';      document       .getElementById('button-tx')       .addEventListener('click', async () => {         const demoMessage = 'Transaction demo from Elven.js!';          const isGuarded = ElvenJS.storage.get('activeGuardian');         // You will need additional 50000 when using guardians         const gasLimit = (isGuarded ? 100000 : 50000) + 1500 * demoMessage.length;          const tx = new Transaction({           nonce: ElvenJS.storage.get('nonce'),           receiver: new Address(egldTransferAddress),           gasLimit,           chainID: 'D',           data: new TransactionPayload(demoMessage),           value: TokenTransfer.egldFromAmount(0.001),           sender: new Address(ElvenJS.storage.get('address')),         });          try {           await ElvenJS.signAndSendTransaction(tx);         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <p>You can also see the transaction instance here. There is a couple of classes exported from sdk-js. You can think of them as helper tools for data preparation. More about them later.</p> <h3>Signing a message</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">await ElvenJS.signMessage(message: string, options?: { callbackUrl?: string }) </code></pre> <p>Sign a custom message using all supported providers. You will get the signature. You can verify the signature wherever you need it. It is usually done on the backend side. To verify, you can use <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/sdk-js-cookbook#verifying-signatures\">sdk-js</a>. Or other MultiversX SDKs.</p> <p><strong>Initialization callbacks</strong><br>Callbacks that will be triggered for that function</p> <pre><code class=\"language-typescript\">onSignMsgStart?: (message: string) => void; onSignMsgFinalized?: (messageSignature: string) => void; onSignMsgFailure?: (message: string, error: string) => void; </code></pre> <p><strong>Arguments</strong>:</p> <ul>   <li><code>message</code>: message to sign</li>   <li><code>options</code>: available only for Web Wallet provider. You can set <code>callbackUrl</code></li> </ul> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-tx\">Sign a message&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS,     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      document       .getElementById('button-tx')       .addEventListener('click', async () => {         try {           await ElvenJS.signMessage('Elven Family is awesome!');         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Querying a smart contract</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">// function await ElvenJS.queryContract(queryArgs: SmartContractQueryArgs) </code></pre> <p><strong>Typings</strong>:</p> <pre><code class=\"language-typescript\">interface QueryArguments {   func: IContractFunction;   args?: TypedValue[];   value?: ITransactionValue;   caller?: IAddress; }  interface SmartContractQueryArgs extends QueryArguments {   address: IAddress; } </code></pre> <p>   <code>QueryArguments</code> is the sdk-js exported <a href=\"https://github.com/multiversx/mx-sdk-js-core/blob/main/src/smartcontracts/interface.ts\">QueryArguments</a> type.   Querying smart contracts is possible with this function. You must pass the smart contract address, function name (smart contract endpoint), and arguments (if it takes any). The value and caller are optional. </p> <p><strong>Arguments</strong>:</p> <ul>   <li><code>address</code> - <code>IAddress</code> interface from sdk-js, you will get it by <code>new Address(&#x3C;string_addres>)</code></li>   <li><code>func</code> - <code>IContractFunction</code> interface from sdk-js, you will get it by <code>new ContractFunction('&#x3C;function_name>')</code></li>   <li><code>args</code> - <code>TypedValue</code> array, you will get it by using one of many helpers like <code>U32Value</code>, <code>AddressValue</code>, <code>BytesValue</code>, etc. You'll learn more about it later</li>   <li><code>value</code> - the value to transfer. It is optional or can be set to 0</li>   <li><code>caller</code> - also <code>Iaddress</code> interface, the same as an address, also optional</li> </ul> <p><strong>Initialization callbacks</strong><br>Callbacks that will be triggered for that function</p> <pre><code class=\"language-typescript\">onQueryStart?: (queryArgs: QueryArguments) => void; onQueryFinalized?: (queryResponse: ContractQueryResponse) => void; onQueryFailure?: (queryArgs: QueryArguments, error: string) => void; </code></pre> <p><strong>Usage example</strong>:</p> <pre><code class=\"language-html\">&#x3C;html> &#x3C;body>   &#x3C;button id=\"button-tx\">Send transaction&#x3C;/button>    &#x3C;script type=\"module\">     import {       ElvenJS,       Address,       AddressValue,       ContractFunction,     } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js';      // Initialization first (see above) ...          // Some other stuff here ...      // You can also use currently logged in user addres: ElvenJS.storage.get('address')     const randomUserAddress = \"erd1druav0mlt7wzutla33kw80ueaalmec7mz2hus5svdmzlfj286qpstg674t\";          document       .getElementById('button-query')       .addEventListener('click', async () => {         try {           await ElvenJS.queryContract({             address: new Address(nftMinterSmartContract),             func: new ContractFunction('getMintedPerAddressTotal'),             args: [new AddressValue(new Address(randomUserAddress))]           });           // You can handle results parsing here or in the initialization callback as in the example         } catch (e) {           throw new Error(e?.message);         }       });   &#x3C;/script> &#x3C;/body> &#x3C;/html> </code></pre> <h3>Storage handling</h3> <pre><code class=\"language-typescript\">ElvenJS.storage.get(); // all keys ElvenJS.storage.get('address'); // single key ElvenJS.storage.set('address', 'erd1...'); // set the value for a key ElvenJS.storage.clear(); </code></pre> <p>Storage is a thin wrapper over the localStorage. All data required for synchronization on page refresh is kept there.</p> <p>Remember that it shouldn't be used as a custom localStorage operations replacement. It has preconfigured localStorage key and should be used only for ElvenJS related operations. Mostly reading the actual state of the application. Below you will find what data you can get:</p> <ul>   <li><code>signature</code> - auth signature when you provide the auth token</li>   <li><code>loginToken</code> - the token you pass in the login function to get the signature back (optional)</li>   <li><code>address</code> - actually logged in erd address</li>   <li><code>activeGuardian</code> - active guardian assigned for the address</li>   <li><code>loginMethod</code> - actually chosen login method, for example, <code>browser-extension</code></li>   <li>     <code>expires</code> - when your current session will expire     <code>balance</code> - your actual Egld balance   </li>   <li><code>nonce</code> - your actual nonce - this one is quite important because you will need it when preparing transactions objects</li> </ul> <p>Example of the localStorage data:</p> <pre><code class=\"language-json\">{   \"signature\":\"42946a91f332eb3e413bc7ac18b8246bca1cb230ef2813ed714cd0417c95a8eb8104ce4e7d7c9ce1fb03853e10e7817416f8a8e789111df89909cd973f41ee0b\",   \"address\":\"erd1druav0mlt7wzutla33kw80ueaalmec7mz2hus5svdmzlfj286qpstg674t\",   \"activeGuardian\": \"erd1cscs8styv2ahllym0twsanezd4v65mcf5fungfvazgsfmuhwlehstadanq\",   \"loginMethod\":\"browser-extension\",   \"expires\":1663881876868,   \"nonce\":166,   \"balance\":\"6089909418940000000\" } </code></pre> <p>The storage key is <code>elvenjs_state</code>.</p> <h3>Destroy and cleanup</h3> <p><strong>Function</strong>:</p> <pre><code class=\"language-typescript\">ElvenJS.destroy() </code></pre> <p>Mostly helpful in single-page applications where you would like to do some cleanup when you don't need the ElvenJS instance anymore.</p> <p><strong>No arguments</strong>.</p> <h3>Exported classes and types from sdk-js</h3> <p>Below is the list of exported helpers, classes, and types from sdk-js. You can read more about them in the <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/sdk-js-cookbook\">sdk-js cookbook</a>, also please check the <a href=\"/docs/recipes.html\">recipes</a> section, where you will find some of the use cases related to these:</p> <ul>   <li><code>TokenTransfer</code></li>   <li><code>TransferTransactionsFactory</code></li>   <li><code>GasEstimator</code></li>   <li><code>Address</code></li>   <li><code>Account</code></li>   <li><code>Transaction</code></li>   <li><code>TransactionPayload</code></li>   <li><code>TransactionWatcher</code></li>   <li><code>SmartContract</code></li>   <li><code>ContractFunction</code></li>   <li><code>BytesType</code></li>   <li><code>BytesValue</code></li>   <li><code>U16Type</code></li>   <li><code>U16Value</code></li>   <li><code>U32Type</code></li>   <li><code>U32Value</code></li>   <li><code>U64Type</code></li>   <li><code>U64Value</code></li>   <li><code>U8Type</code></li>   <li><code>U8Value</code></li>   <li><code>BigUIntType</code></li>   <li><code>BigUIntValue</code></li>   <li><code>BooleanType</code></li>   <li><code>BooleanValue</code></li>   <li><code>AddressType</code></li>   <li><code>AddressValue</code></li>   <li><code>SignableMessage</code></li>   <li><code>QueryArguments</code></li>   <li><code>ContractQueryResponse</code></li> </ul> <p>You can import them directly from elven.js without the ElvenJS namespace. Like:</p> <pre><code class=\"language-typescript\">import {   Address,   ContractCallPayloadBuilder,   ContractFunction } from 'https://unpkg.com/elven.js@0.17.0/build/elven.js'; </code></pre> <p>There will probably be more of them, but the ElvenJS library should be as small as possible. Maybe some of them will land in separate libraries like the planned query results parser library.</p> <h3>Summary</h3> <p>You learned about all functions from ElvenJS. The library will undoubtedly get some more functionality in the future, but for now, this is enough to let you build dApps and widgets on your existing websites.</p> <p>Please check the <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">JS SDK</a> tools for more info on some of the types and classes described here, and for sure, reading the <a href=\"/docs/recipes.html\">recipes</a> section will be beneficial.</p>","excerpt":"Elven.js - the JavaScript SDK for the MultiversX blockchain. Compact and simplified wrapper for sdk-js!","publicationDate":"2022-09-20","tags":["intro"],"coverImage":""}]